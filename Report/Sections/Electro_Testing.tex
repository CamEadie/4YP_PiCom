\documentclass[../main.tex]{subfiles}
	% ELECTRONICS TESTING
\begin{document}

Assessing the electronic capabilities of the test bed is split into three main sections.
The first and second sections deal with the electrical and computational characteristics respectively of the Raspberry Pi, and the third deals with the components used in the test bed.
The electrical section pertains to the GPIO pins and their physical capabilities, whereas the computational section considers how fast the pin values can be changed and read by the underlying code, and how most efficiently to achieve this.
The final section discusses limitations to the operation of the test bed which are posed by the components used.\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Electrical Characteristics of the Raspberry Pi}

The Raspberry Pi 3B has 40 pins, including eight ground pins, two \SI{3.3}{\volt} power pins and two \SI{5}{\volt} power pins.
26 of the remaining pins (BCM pins 2 to 27) are free to be used as General Purpose Input/Output (GPIO).
The GPIO pins can output low (\SI{0}{\volt}) and high (\SI{3.3}{\volt}) levels, and they are powered by the same \SI{3.3}{\volt} rail as the power pins of the same voltage.
As a result, there is a maximum current that can be drawn from all of these pins together as well as from each GPIO pin individually.\\

The Embedded Linux Wiki \cite{web_RpiMaxRatings} claims that the \SI{5}{\volt} pins can provide a maximum current equal to, "The USB [power cable] input current (usually \SI{1}{\ampere}) minus any current draw from the rest of the board."
It also provides the maximum current to be drawn from all \SI{3.3}{\volt} power pins as \SI{50}{\milli\ampere} (this would apply to the power pins and the GPIO pins combined).
However that specification was actually a design value for the original Pi, designed to supply \SI{3}{\milli\ampere} for each of its17 pins for $\approx \SI{51}{\milli\ampere}$ total, according to Gert Van Loo, the hardware engineer of the first Pi's boards \cite{web_RPiSpecsSE}.
There is no current-limiting on the pins so they will attempt to drive the current pulled they stops working, however multiple sources including Gert Van Loo suggest that the maximum current that should be drawn from any one pin for safe operation is \SI{16}{\milli\ampere} as this is the current to which the electronics on each pad are rated.
Mosaic Documentation Web also has a page attempting to define the electrical specifications of the Raspberry Pi \cite{web_MosaicSpecs}, and it also suggests that one shouldn't attempt to source or sink more than \SI{16}{\milli\ampere} on an output pin.
The pins actually have a set drive strength from \SIrange{2}{16}{\milli\ampere} in \SI{2}{\milli\ampere} increments which is set for a bank of pins and usually set to \SI{8}{\milli\ampere} but even a pin set to \SI{2}{\milli\ampere} drive strength and then loaded so as to draw \SI{16}{\milli\ampere} will not be damaged \cite{web_GPIOPadsErrata}.\\

The maximum current which can be drawn from an output pin is a useful detail.
This is both in order to ensure that none of the attached components draw too much current, as well as to decide, along with the input impedances of the pins, whether or not the GPIO pins of one Pi can be connected directly to another without a protective resistor between them.
It is important that the ground pins of the two Raspberry Pis must be connected together so that they share a common reference for the data levels.
The input and output impedances of the pins in various set-up modes are shown in Table \ref{tab_Pin Impedances}.
All values were measured on a multi-meter and using the pin GPIO26 and compared to other pins to check consistency.
Pins 2 and 3 have permanent internal pull-up resistors whereas all of the rest have software-controllable pull-up or pull-down resistors which can be set for inputs.\\

\begin{table}[h]
	\centering
	\global\tabulinesep = 2mm
	\begin{tabu} to 0.8\textwidth { | X[l] | X[c] | }
		\hline
		Input/Output Mode & Impedance to Ground ($\SI{}{\kilo\ohm}$)\\
		\hline\hline
		Input & Open Loop\\
		\hline
		Input with Pull Up Resistor  & 53 250\\
		\hline
		Input with Pull Down Resistor  & 49.24\\
		\hline
		Output & 0.0329\\
		\hline
		Raspberry Pi ON (No Mode) & 49.23\\
		\hline
		Raspberry Pi OFF & 606.14\\
		\hline
	\end{tabu}
	\caption{Table of GPIO Pin Impedances for Different Operating Modes}
	\label{tab_Pin Impedances}
\end{table}

These impedances show that even the lowest input impedance of \SI{48.93}{\kilo\ohm} will only draw \SI{67.44}{\micro\ampere} of current from a \SI{3.3}{\volt} GPIO pin, and this is three orders of magnitude lower than the maximum current these pins can supply.
The impedance of pins set to be outputs is the only value lower than this at \SI{32.9}{\ohm}, and so if an output at \SI{0}{\volt} were connected to another pin at \SI{3.3}{\volt} it would potentially draw about \SI{100}{\milli\ampere} which would damage both pins or at least (the Raspberry Pi has safeguards excessive currents) restart the Pi.
This is unlikely to happen in the test bed setup however, unless an output pin was directly connected to a \SI{3.3}{\volt} power pin, or both Pis had directly connected pins set as outputs.
In conclusion, the pins of two Raspberry Pis can be directly connected together, as long as care is taken not to have both devices setting these pins to outputs at the same time .\\

%\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Computational Characteristics of the Raspberry Pi} \label{sec_Computation}

\todo[inline,color=blue!20]{Write Computing and Components Sections - I have all the data, screen shots and component characterising values}

The Raspberry Pi is not a real-time device.
Running under an operating system, there will always be interrupts due to scheduling of different threads, which mean that code execution may not always be as perfectly timed as it would on a dedicated embedded device like an Arduino.
The Raspberry Pi has certain advantages however; Python is significantly more versatile for signal processing, and the Raspberry Pi B+ has a \SI{1.4}{\giga\hertz} processor compared to the Arduino Uno's \SI{16}{\mega\hertz} clock \cite{lib_Arduino}.
There are also ways of ensuring the Pi operates as close to real time as possible.\\

The time-sensitive parts of the code are the actual pin manipulations in the transmitter, and the reading in of the pin values in the receiver.
This means that these need to be the parts optimised for speed.

System interrupts can be turned off in the code, however this results in nothing else being run on the computer, essentially freezing it until the interrupts are turned back on \cite{web_Interrupts}.
This should not be done for too long as it is bad for the Pi, and as the transmitter and receiver may be used to transmit a significant amount of data, this is not suggestible without periodically turning on interrupts to allow them to run, losing samples at the receiver to the backlog of interrupts.
However, there is one particularly inhibiting interrupt - adjusting of the refresh rate of RAM every 500ms - which can be turned off \cite{web_PiOscilloscope}.
This is achieved with the terminal command in Listing \ref{lst_RAM Refresh}.\\

\lstset{style=C}
\begin{lstlisting}[caption={Turning off the RAM refresh rate adjustment}, label={lst_RAM Refresh}]
	sudo sed -i '$s/$/\ndisable_pvt=1/' /boot/config.txt
\end{lstlisting}


DIWINE White Paper 2 \cite{pap_DIWINEpaper2} at the end of the second year in a three year project, they still had "'time zero' reference" between the terminal nodes for synchronisation.

time.time() in for loop - 3.32 us
time.time() in while loop with i++ - 4.02 us = slower
time.time() sequential - 2.81 us
therefore for loop time - 0.51us

100Hz (excluding the 10ms)
sleep(1/freq) - 104.13 us
sleep(1/freq-timeDif) - 90.08 us == REMOVES DELAY OF ~15us - GPIO AND A BIT
SAME without sleep(1/freq) (just GPIO) - 5.18 us
SAME without GPIO.output (just sleep(1/freq)) - 97.18 us == SLEEP IS THE INEFFICIENT FUNCTION LOSING ME TIME
You can hard-code in the ~104e-6 value to get offset of ~5us instead of 104us but this is not ideal - need to compare to coding in c...\\

Table from interim report and two screen shots in particular.\\

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{Benchmarking_Data.jpg}
	\caption{Benchmarking initial data collection}
	%\label{fig_}
\end{figure}

\subsection{Comparing Python and C} \label{sec_Comparing Python and C}

Python is implemented as an interpreted language, meaning that the code (or at least an intermediate byte-code representation) is interpreted by a virtual machine at runtime.
This means that, although a lot more powerful, Python can have drawbacks in performance relative to C, which is compiled into executable machine code prior to being run.
An article from 2015 benchmarking the frequency achieved by switching a GPIO on and off continuously suggests that the Python library RPi.GPIO achieved the highest frequency of Python libraries, at \SI{70}{\kilo\hertz} \cite{web_BenchmarkingPi}.
It also suggested that all of the C libraries achieved frequency ranges in the Megahertz.
The libraries have been updated to improve efficiency, but if C is found to be a significantly better option, then the pin manipulations of the transmitter and receiver themselves should be written in C and compiled into executables which the main Python code-base can run.

\subsection{Maximum Frequency}

\todo[inline,color=blue!20]{Comparison of transmitter bank vs individual write and receiver read (callback) and read vars on clock pulse vs bank read on clock pulse -- Also mention }
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.8\textwidth]{Write_Time_Test.png}
	\caption{Write Time Test}
	%\label{fig_}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.8\textwidth]{Read_Time_Test.png}
	\caption{Read Time Test}
	%\label{fig_}
\end{figure}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Characterising Components of the Test Bed} \label{sec_Components}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.4\textwidth]{DAC_Output.jpg}
	\caption{Non-continuous Output for Continuous Input Values of the DAC}
	%\label{fig_}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.6\textwidth]{Pulse_Output.jpg}
	\caption{Output of pulse generator}
	%\label{fig_}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.6\textwidth]{Sine_Output.jpg}
	\caption{Output of pulse generator once filtered to be sine waves}
	%\label{fig_}
\end{figure}



Electrical Components:
\begin{itemize}
	\item Analogue Digital Converter
	\item Digital Analogue Converter
	\item Quadrature Sinusoid Generator
	\item Multiplier/Mixer
	\item Low Pass Filters
\end{itemize}

\subsection{Overclocking Components} \label{sec_Overclocking}

The \textit{pigpio} library has access to the hardware clocks of the Raspberry Pi.
Specifically on the Pis used, it has the ability to set a hardware clock which is not reserved for system use to a specified frequency between \SI{4.7}{\kilo\hertz} and \SI{250}{\mega\hertz} on pin 4, although the library documentation suggests that frequencies above \SI{30}{\mega\hertz} are unlikely to work \cite{lib_pigpioHWClock}.\\

There are certain components such as the Analogue Digital Converter and the pulse generator which work using an internal clock set by an external resistor, but which may be overclocked by an external clocking signal, and this functionality may be used.
This would allow the frequencies of these devices to be defined in software with less reliance on external physical components.
The pulse generator isn't as good an example as it still uses external filtering to generate sinusoidal outputs, but this is particularly relevant for the ADC as it requires eight clock pulses per conversion, and setting a hardware clock for (at least) eight times the transmission frequency is one way of ensuring this in software.\\

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.6\textwidth]{Clock_Analyse.jpg}
	\caption{This is a high frequency view of the hardware clock for interest and rise-time (max frequency achievable actually) - will analyse screen grab from Oscilloscope and include in report}
	%\label{fig_}
\end{figure}


\end{document}